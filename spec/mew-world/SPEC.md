# MEW Protocol Isometric Multiplayer Game - Specification

## Overview

This game is a multiplayer isometric 2D world where participants (humans and AI agents) can move around, interact, and board ships. Built with Phaser 3 (v3.90.0) and TypeScript, it uses an Electron-based client that connects to a MEW protocol space. All participants communicate their positions and actions through MEW protocol streams, enabling real-time synchronization. The game features a space template with 4 human slots and 4 AI agent slots, where agents use an extended MEWAgent class with navigation capabilities. Ships act as movable platforms controlled through MCP tools, with players able to walk on them and be carried as the ship moves, requiring a relative coordinate system to handle movement on moving platforms.

## Client Architecture

The Electron application serves as the game client, presenting a connection form on launch where users enter the MEW gateway URL, port, username, and authentication token. Once connected, the client establishes a WebSocket connection to the MEW space using the MEW SDK client. The Phaser 3 game engine runs within the Electron window, rendering the isometric world and handling all game logic, input, and rendering. The client subscribes to MEW protocol streams to receive position updates from other participants and publishes its own position changes through the same mechanism. The client maintains a local game state synchronized with the MEW space, handling latency and reconciling any conflicts between local predictions and authoritative server state received via the protocol.

## Player System

All participants in the game are represented as players with a common base interface, though the system is designed to support different player types in the future with varying abilities and sprites. Each player has an MCP tool called `get_player_info` that returns their player type, current position, sprite identifier, movement speed, and any special abilities. For the initial implementation, all players share the same sprite and movement characteristics. Players interact with the world through MCP tools: `move_to` for pathfinding to a destination tile, `move_direction` for direct movement commands, and `get_position` for querying current location. The player system tracks whether a player is standing on solid ground or on a ship platform, which affects how their movement commands are interpreted and executed.

## Movement & Networking

Player movement is communicated through MEW protocol streams using a dedicated `player/position` stream that all participants subscribe to. Each position update message contains the player's participant ID, world coordinates (x, y), tile coordinates for the isometric grid, velocity vector, timestamp, and optional platform reference if standing on a ship. The game uses client-side prediction where local players see immediate movement feedback, while remote players' positions are interpolated smoothly based on received updates. The stream handler applies dead reckoning to estimate positions between updates and implements lag compensation to ensure fair gameplay despite network latency. Movement speed is measured in tiles per second, with the game loop updating positions at 60 FPS and broadcasting position updates at a configurable rate (default 10 Hz) to balance network efficiency with visual smoothness.

## AI Agent System

AI agents extend the base MEWAgent class with a new `GameAgent` superclass that adds spatial reasoning and autonomous navigation capabilities. This superclass provides MCP tools that wrap the core movement system, allowing the AI to call `decide_next_move` which returns available adjacent tiles with metadata about terrain, obstacles, and other players. The AI uses Claude's reasoning to select a destination tile based on goals, then calls `execute_move` to initiate pathfinding. The GameAgent implements an A* pathfinding algorithm to navigate around obstacles and other players, respecting the movement speed constraints of the player type. The AI decision loop runs at a slower cadence (1-2 Hz) to avoid excessive API calls, with the pathfinding system handling smooth execution of multi-tile movements. GameAgents can have high-level goals set through their system prompt, such as "explore the world," "follow other players," or "patrol an area," which guide their decision-making process.

## Ship System

Ships are movable platforms implemented as non-AI MEW participants backed by an MCP server that provides rule-based control tools. Each ship has an MCP tool interface including `set_sail_direction` to control heading, `set_sail_speed` to adjust velocity, `get_ship_position` for current location, and `get_passengers` to list players currently on the ship. The ship MCP server maintains the ship's position and broadcasts updates through the same `player/position` stream used by regular players, using a special participant ID. The ship has a defined collision boundary and walkable deck area represented as a set of relative tile coordinates. When a player moves to a tile that intersects with a ship's boundary, the game engine automatically registers them as "on ship" and changes their coordinate reference frame from world-absolute to ship-relative. The ship server runs a simple physics loop that updates the ship's world position based on its velocity vector, checking for collisions with land or other ships.

## Coordinate Systems & Relative Movement

The game implements a dual coordinate system to handle players moving on moving platforms. World coordinates are absolute positions in the game world, while platform coordinates are relative offsets from a platform's origin point (used when standing on a ship). Each player's state includes a `platform_ref` field that is null when on solid ground or references a ship participant ID when aboard. When a player is on a ship, their world position is calculated as `ship.world_position + player.platform_offset`, recalculated every frame as the ship moves. Movement commands from players on ships are interpreted as relative movements within the ship's coordinate frame, with collision detection checking against the ship's deck boundaries rather than world terrain. The rendering system transforms ship-relative coordinates to screen space by first applying the ship's world transform, then the player's relative offset, ensuring players appear to move correctly both when walking on a stationary ship and when walking on a moving ship.
